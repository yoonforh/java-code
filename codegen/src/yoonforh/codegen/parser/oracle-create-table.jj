/*
 * $Id: oracle-create-table.jj,v 1.2 2003/05/31 07:19:24 yoonforh Exp $
 *
 * Copyright (c) 2003 by Yoon Kyung Koo.
 * All rights reserved.
 * 
 * This software is the confidential and proprietary information
 * of Yoon Kyung Koo("Confidential Information").  You
 * shall not disclose such Confidential Information and shall use
 * it only in accordance with the terms of the license agreement
 * you entered into with Yoon Kyung Koo.
 */

options {
    IGNORE_CASE = true;
    UNICODE_INPUT = true; // accept non-ascii input
//    DEBUG_PARSER = true;
//     USER_CHAR_STREAM = true;
}

PARSER_BEGIN(OracleCreateTableParser)


package yoonforh.codegen.parser;

import java.io.*;
import java.util.*;
// import yoonforh.codegen.parser.safer.BackupCharStream;

/**
 * refer to Oracle 9i SQL reference
 *
 * @version  $Revision: 1.2 $<br>
 *           created at 2003-04-14 15:21:19
 * @author   Yoon Kyung Koo
 */

public class OracleCreateTableParser {
    /** test run */
    public static void main(String[] args) throws ParseException, IOException {
	if (args.length < 1) {
	    System.err.println("usage : java OracleCreateTableParser <sql file name>");
	    System.exit(0);
	}
	OracleCreateTableParser parser = new OracleCreateTableParser(
				new FileInputStream(args[0]));
/*
	SimpleNode node = parser.SQLSheet();
	node.dump(">");
*/
	HashMap tableMap = new HashMap();
	parser.SQLSheet(tableMap);
	System.out.println("parse result map - " + tableMap);
    }

    public static class TableInfo implements Serializable {
	private String name = null;
	private ArrayList pkList = new ArrayList();
	private HashMap fieldMap = new HashMap();

	public TableInfo(String name) {
	    this.name = name;
	}

	public String getName() { return name; }
	public ArrayList getPKList() { return pkList; }
	public HashMap getFieldMap() { return fieldMap; }
	public void setName(String name) { this.name = name; }

	public void addPK(String pk) {
	    pkList.add(pk);
	}

	public void addField(String name, FieldType type) {
	    fieldMap.put(name, type);
	}

	public String toString() {
	    return "TableInfo(name - " + name
		+ ", pk list - " + pkList
		+ ", field map - " + fieldMap
		+ ")";
	}
    }

    public static class FieldType implements Serializable {
	private String name = null;
	private String size = null;

	public FieldType(String name) {
	    this(name, null);
	}

	public FieldType(String name, String size) {
	    this.name = name;
	    this.size = size;
	}

	public String getName() { return name; }
	public String getSize() { return size; }
	public void setName(String name) { this.name = name; }
	public void setSize(String size) { this.size = size; }

	public String toString() {
	    return "FieldType(name - " + name + ", size - " + size + ")";
	}
    }

//     // JavaCC hack for doing lexical state transitions syntactically

//     private static void SetState(int state) {
// 	if (state != token_source.curLexState) {
// 	    Token root = new Token(), last=root;
// 	    root.next = null;

// 	    // First, we build a list of tokens to push back, in backwards order
// 	    while (token.next != null) {
// 		Token t = token;
// 		// Find the token whose token.next is the last in the chain
// 		while (t.next != null && t.next.next != null)
// 		    t = t.next;

// 		// put it at the end of the new chain
// 		last.next = t.next;
// 		last = t.next;

// 		// If there are special tokens, these go before the regular tokens,
// 		// so we want to push them back onto the input stream in the order
// 		// we find them along the specialToken chain.

// 		if (t.next.specialToken != null) {
// 		    Token tt=t.next.specialToken;
// 		    while (tt != null) {
// 			last.next = tt;
// 			last = tt;
// 			tt.next = null;
// 			tt = tt.specialToken;
// 		    }
// 		}
// 		t.next = null;
// 	    };

// 	    while (root.next != null) {
// 		token_source.backup(root.next.image.length());
// 		root.next = root.next.next;
// 	    }
// 	    jj_ntk = -1;
// 	    token_source.SwitchTo(state);
// 	}
//     }


}

PARSER_END(OracleCreateTableParser)

// TOKEN_MGR_DECLS : {
//     // Required by SetState
//     void backup(int n) { input_stream.backup(n); } 
// }

/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  "--" : IN_SINGLE_LINE_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

<UNSUPPORTED_STATEMENT>
SPECIAL_TOKEN :
{
  <END_OF_STATEMENT : ";" | "/" > : DEFAULT
}

<UNSUPPORTED_STATEMENT>
MORE :
{
  < ~[] >
}

/* ORACLE 9i RESERVED WORDS */
TOKEN :
{
  < ACCESS : "access" >
| < ADD : "add" >
| < ALL : "all" >
| < ALTER : "alter" >
| < AND : "and" >
| < ANY : "any" >
| < AS : "as" >
| < ASC : "asc" >
| < AUDIT : "audit" >
| < BETWEEN : "between" >
| < BY : "by" >
| < CHAR : "char" >
| < CHECK : "check" >
| < CLUSTER : "cluster" >
| < COLUMN : "column" >
| < COMMENT : "comment" >
| < COMPRESS : "compress" >
| < CONNECT : "connect" >
| < CREATE : "create" >
| < CURRENT : "current" >
| < DATE : "date" >
| < DECIMAL : "decimal" >
| < DEFAULT_STRING : "default" >
| < DELETE : "delete" >
| < DESC : "desc" >
| < DISTINCT : "distinct" >
| < DROP : "drop" >
| < ELSE : "else" >
| < EXCLUSIVE : "exclusive" >
| < EXISTS : "exists" >
| < FILE : "file" >
| < FLOAT : "float" >
| < FOR : "for" >
| < FROM : "from" >
| < GRANT : "grant" >
| < GROUP : "group" >
| < HAVING : "having" >
| < IDENTIFIED : "identified" >
| < IMMEDIATE : "immediate" >
| < IN : "in" >
| < INCREMENT : "increment" >
| < INDEX : "index" >
| < INITIAL : "initial" >
| < INSERT : "insert" >
| < INTEGER : "integer" >
| < INTERSECT : "intersect" >
| < INTO : "into" >
| < IS : "is" >
| < LEVEL : "level" >
| < LIKE : "like" >
| < LOCK : "lock" >
| < LONG : "long" >
| < MAXEXTENTS : "maxextents" >
| < MINUS : "minus" >
| < MLSLABEL : "mlslabel" >
| < MODE : "mode" >
| < MODIFY : "modify" >
| < NOAUDIT : "noaudit" >
| < NOCOMPRESS : "nocompress" >
| < NOT : "not" >
| < NOWAIT : "nowait" >
| < NULL : "null" >
| < NUMBER : "number" >
| < OF : "of" >
| < OFFLINE : "offline" >
| < ON : "on" >
| < ONLINE : "online" >
| < OPTION : "option" >
| < OR : "or" >
| < ORDER : "order" >
| < PCTFREE : "pctfree" >
| < PRIOR : "prior" >
| < PRIVILEGES : "privileges" >
| < PUBLIC : "public" >
| < RAW : "raw" >
| < RENAME : "rename" >
| < RESOURCE : "resource" >
| < REVOKE : "revoke" >
| < ROW : "row" >
| < ROWID : "rowid" >
| < ROWNUM : "rownum" >
| < ROWS : "rows" >
| < SELECT : "select" >
| < SESSION : "session" >
| < SET : "set" >
| < SHARE : "share" >
| < SIZE : "size" >
| < SMALLINT : "smallint" >
| < START : "start" >
| < SUCCESSFUL : "successful" >
| < SYNONYM : "synonym" >
| < SYSDATE : "sysdate" >
| < TABLE : "table" >
| < THEN : "then" >
| < TO : "to" >
| < TRIGGER : "trigger" >
| < UID : "uid" >
| < UNION : "union" >
| < UNIQUE : "unique" >
| < UPDATE : "update" >
| < USER : "user" >
| < VALIDATE : "validate" >
| < VALUES : "values" >
| < VARCHAR : "varchar" >
| < VARCHAR2 : "varchar2" >
| < VIEW : "view" >
| < WHENEVER : "whenever" >
| < WHERE : "where" >
| < WITH : "with" >
}

/* UNRESERVED KEYWORDS */

TOKEN :
{
  < ALWAYS : "always" >
| < ANALYZE : "analyze" >
| < ASSOCIATE : "associate" >
| < AT : "at" >
| < BFILE : "bfile" >
| < BITMAP : "bitmap" >
| < BLOB : "blob" >
| < BODY : "body" >
| < BUFFER_POOL : "buffer_pool" >
| < BYTE : "byte" >
| < CACHE : "cache" >
| < CALL : "call" >
| < CASCADE : "cascade" >
| < CASE : "case" >
| < CHARACTER : "character" >
| < CHUNK : "chunk" >
| < CLOB : "clob" >
| < COLUMN_VALUE : "column_value" >
| < COMMIT : "commit" >
| < COMPUTE : "compute" >
| < CONSTRAINT : "constraint" >
| < CONTEXT : "context" >
| < CONTROLFILE : "controlfile" >
| < CUBE : "cube" >
| < CURRVAL : "currval" >
| < CURSOR : "cursor" >
| < DATABASE : "database" >
| < DAY : "day" >
| < DBTIMEZONE : "dbtimezone" >
| < DEC : "dec" >
| < DEFERRABLE : "deferrable" >
| < DEFERRED : "deferred" >
| < DIMENSION : "dimension" >
| < DIRECTORY : "directory" >
| < DISABLE : "disable" >
| < DISASSOCIATE : "disassociate" >
| < DOUBLE : "double" >
| < ELEMENT : "element" >
| < ENABLE : "enable" >
| < END : "end" >
| < EQUALS_PATH : "equals_path" >
| < ESCAPE : "escape" >
| < EXCEPTIONS : "exceptions" >
| < EXPLAIN : "explain" >
| < EXTERNAL : "external" >
| < FIRST : "first" >
| < FOREIGN : "foreign" >
| < FREELIST : "freelist" >
| < FREELISTS : "freelists" >
| < FREEPOOLS : "freepools" >
| < FUNCTION : "function" >
| < GLOBAL : "global" >
| < GROUPING : "grouping" >
| < GROUPS : "groups" >
| < HASH : "hash" >
| < HEAP : "heap" >
| < HH : "hh" >
| < INCLUDING : "including" >
| < INDEXTYPE : "indextype" >
| < INDICATOR : "indicator" >
| < INITIALLY : "initially" >
| < INITRANS : "initrans" >
| < INT : "int" >
| < INTERVAL : "interval" >
| < JAVA : "java" >
| < KEEP : "keep" >
| < KEY : "key" >
| < LAST : "last" >
| < LESS_STRING : "less" >
| < LEVELS : "levels" >
| < LIBRARY : "library" >
| < LIKE2 : "like2" >
| < LIKE4 : "like4" >
| < LIKEC : "likec" >
| < LIMIT : "limit" >
| < LINK : "link" >
| < LIST : "list" >
| < LOB : "lob" >
| < LOCAL : "local" >
| < LOCATION : "location" >
| < LOCATOR : "locator" >
| < LOG : "log" >
| < LOGGING : "logging" >
| < MAPPING : "mapping" >
| < MATERIALIZED : "materialized" >
| < MAXTRANS : "maxtrans" >
| < MAXVALUE : "maxvalue" >
| < MERGE : "merge" >
| < MINEXTENTS : "minextents" >
| < MM : "mm" >
| < MONITORING : "monitoring" >
| < MONTH : "month" >
| < MOVEMENT : "movement" >
| < NATIONAL : "national" >
| < NCHAR : "nchar" >
| < NCLOB : "nclob" >
| < NESTED : "nested" >
| < NEW : "new" >
| < NEXT : "next" >
| < NEXTVAL : "nextval" >
| < NOCACHE : "nocache" >
| < NOLOGGING : "nologging" >
| < NOMAPPING : "nomapping" >
| < NOMONITORING : "nomonitoring" >
| < NOPARALLEL : "noparallel" >
| < NORELY : "norely" >
| < NOROWDEPENDENCIES : "norowdependencies" >
| < NOSORT : "nosort" >
| < NOVALIDATE : "novalidate" >
| < NULLS : "nulls" >
| < NUMERIC : "numeric" >
| < NVARCHAR2 : "nvarchar2" >
| < OBJECT : "object" >
| < ONLY : "only" >
| < OPERATOR : "operator" >
| < OPTIMAL : "optimal" >
| < ORGANIZATION : "organization" >
| < OUTLINE : "outline" >
| < OVERFLOW : "overflow" >
| < PACKAGE : "package" >
| < PARALLEL : "parallel" >
| < PARAMETERS : "parameters" >
| < PARTITION : "partition" >
| < PARTITIONS : "partitions" >
| < PCTHRESHOLD : "pcthreshold" >
| < PCTINCREASE : "pctincrease" >
| < PCTUSED : "pctused" >
| < PCTVERSION : "pctversion" >
| < PFILE : "pfile" >
| < PRECISION : "precision" >
| < PRESERVE : "preserve" >
| < PRIMARY : "primary" >
| < PROCEDURE : "procedure" >
| < QUOTE : "'" >
| < RANGE : "range" >
| < READS : "reads" >
| < REAL : "real" >
| < RECYCLE : "recycle" >
| < REF : "ref" >
| < REFERENCES : "references" >
| < REJECT : "reject" >
| < RELATIONAL : "relational" >
| < RELY : "rely" >
| < RETENTION : "retention" >
| < RETURN : "return" >
| < REVERSE : "reverse" >
| < ROLE : "role" >
| < ROLLBACK : "rollback" >
| < ROLLUP : "rollup" >
| < ROWDEPENDENCIES : "rowdependencies" >
| < SAVEPOINT : "savepoint" >
| < SCHEMA : "schema" >
| < SCOPE : "scope" >
| < SECOND : "second" >
| < SEGMENT : "segment" >
| < SEQUENCE : "sequence" >
| < SESSIONTIMEZONE : "sessiontimezone" >
| < SETS : "sets" >
| < SHARP : "#" >
| < SIBLINGS : "siblings" >
| < SOME : "some" >
| < SORT : "sort" >
| < SPFILE : "spfile" >
| < STATISTICS : "statistics" >
| < STORAGE : "storage" >
| < STORE : "store" >
| < SUBPARTITION : "subpartition" >
| < SUBPARTITIONS : "subpartitions" >
| < SUBSTITUTABLE : "substitutable" >
| < SUPPLEMENTAL : "supplemental" >
| < TABLESPACE : "tablespace" >
| < TEMPLATE : "template" >
| < TEMPORARY : "temporary" >
| < THAN : "than" >
| < TIME : "time" >
| < TIMESTAMP : "timestamp" >
| < TRUNCATE : "truncate" >
| < TYPE : "type" >
| < UNDER_PATH : "under_path" >
| < UNLIMITED : "unlimited" >
| < UROWID : "urowid" >
| < USING : "using" >
| < VALUE : "value" >
| < VARRAY : "varray" >
| < VARYING : "varying" >
| < WHEN : "when" >
| < XMLSCHEMA : "xmlschema" >
| < XMLTYPE : "xmltype" >
| < YEAR : "year" >
| < ZONE : "zone" >
}

TOKEN:  /* Separators and operators */
{
    < ASSIGN: ":=" >
  | < CONCAT: "||" >
  | < SEMICOLON: ";" >
  | < DOT: "." >
  | < ROWTYPE: "%ROWTYPE" >
  | < TILDE: "~" >
  | < JOINPLUS: "(+)" >
  | < OPENPAREN: "(" >
  | < CLOSEPAREN: ")" >
  | < ASTERISK: "*" >
  | < SLASH: "/" >
  | < PLUS: "+" >
  | < MINUS_OP: "-" >
  | < QUESTIONMARK: "?" >
  | < LESS: "<" >
  | < LESSEQUAL: "<=" >
  | < GREATER: ">" >
  | < GREATEREQUAL: ">=" >
  | < EQUAL: "=" >
  | < NOTEQUAL: "!=" >
  | < NOTEQUAL2: "<>" >
}

/* IDENTIFIER */
TOKEN:
{
	< IDENTIFIER: ( <LETTER> )+ ( <DIGIT> | <LETTER> |<SPECIAL_CHARS>)* >
| 	< LETTER: ["a"-"z", "A"-"Z"] >
|   < #SPECIAL_CHARS: "$" | "_">
|   < BIND: ":" <IDENTIFIER> ("." <IDENTIFIER>)? >
|   < CHAR_LITERAL: "'" (~["'"])* "'" ("'" (~["'"])* "'")*>
|   < QUOTED_IDENTIFIER: "\"" (~["\n","\r","\""])* "\"" >
}

/* Numeric Constants */
TOKEN:
{
    < DIGIT : [ "0" - "9" ] >
}

/***********************************************
 * THE ORACLE CREATE TABLE GRAMMAR STARTS HERE *
 ***********************************************/

/*
 * @param tableMap <table name> - <TableInfo> map
 */
void SQLSheet(HashMap tableMap) :
{}
{
    (
      (
        LOOKAHEAD(4)
          CreateTableStatement(tableMap) ( "/" | ";" )
      | LOOKAHEAD(3)
          CreateIndexStatement() ( "/" | ";" )
      | LOOKAHEAD(2)
          SkipUnsupportedStatement()
      )
      
    )*
    <EOF>
}

/*
 * here we only deal with relation table creation
 */
void CreateTableStatement(HashMap tableMap) :
{
    String tableName = null;
    TableInfo tableInfo = null;
}
{
    "create" [ "global" "temporary" ] 
    "table" [ LOOKAHEAD(2) Schema() "." ]
    tableName = Table()
    {
	tableInfo = new TableInfo(tableName.toLowerCase());
	tableMap.put(tableName.toLowerCase(), tableInfo);
    }
    [ "(" RelationalProperties(tableInfo) ")" ]
    [ "on" "commit" ( "delete" | "preserve" ) "rows" ]
    (LOOKAHEAD( PhysicalProperties() ) PhysicalProperties() | {})
    (LOOKAHEAD( TableProperties(tableInfo) ) TableProperties(tableInfo) | {})
}

/*
JAVACODE
void SkipUnsupportedStatement() {
  Token t;

  System.out.println("Unsupported statement ---");
  while (true) {
      t = getToken(1);
      if ("/".equals(t.image) || ";".equals(t.image)) {
	  return;
      }
      System.out.print(t.image);
      System.out.print(" ");
      t = getNextToken();
  }
}
*/

void SkipUnsupportedStatement() :
{}
{
  (
    <CREATE>
    (
      <CLUSTER>
    | <CONTEXT>
    | <CONTROLFILE>
    | <DATABASE> [ <LINK> ]
    | <DIMENSION>
    | <DIRECTORY>
    | <FUNCTION>
    | <INDEXTYPE>
    | <JAVA>
    | <LIBRARY>
    | <MATERIALIZED> <VIEW> [ <LOG> ]
    | <OPERATOR>
    | <OUTLINE>
    | <PACKAGE> [ <BODY> ]
    | <PFILE>
    | <PROCEDURE>
    | <ROLE>
    | <ROLLBACK> <SEGMENT>
    | <SCHEMA>
    | <SEQUENCE>
    | <SPFILE>
    | <SYNONYM>
    | <TABLESPACE>
    | <TEMPORARY> <TABLESPACE>
    | <TRIGGER>
    | <TYPE> [ <BODY> ]
    | <USER>
    | <VIEW>
    )
  | <ALTER> | <DROP> | <ANALYZE> | <ASSOCIATE> | <AUDIT>
  | <CALL> | <COMMENT> | <COMMIT> | <DELETE> | <DISASSOCIATE>
  | <ROLLBACK> | <EXPLAIN> | <GRANT> | <INSERT> | <LOCK> | <MERGE>
  | <NOAUDIT> | <RENAME> | <REVOKE> | <SAVEPOINT> | <SELECT> | <SET>
  | <TRUNCATE> | <UPDATE>
  )
  {
  Token t;

  System.out.println("Unsupported statement ---");
  while (true) {
      t = getToken(1);
      if (t.kind == SLASH || t.kind == SEMICOLON) {
	  t = getNextToken();
	  System.out.println("next token gotten is " + t.image);
	  return;
      }
      System.out.println("\tUNSUPPROTED TOKEN : " + t.image);
      t = getNextToken();
  }
//      token_source.SwitchTo(UNSUPPORTED_STATEMENT);
//       SetState(UNSUPPORTED_STATEMENT);
  }
}

void RelationalProperties(TableInfo tableInfo) :
{}
{
    RelationalProperty(tableInfo) ( "," RelationalProperty(tableInfo) )*
}

void RelationalProperty(TableInfo tableInfo) :
{
  String columnName = null;
  FieldType type = null;
  boolean isPK = false;
  boolean wasPK = false;
}
{
  (
    columnName = Column()
    type = Datatypes()
    {
      tableInfo.addField(columnName.toLowerCase(), type);
    }
    [ "default" Expr() ]
      (
        // maybe the reference document is wrong. InlineConstraint can be
        // multiple. think of PRIMARY KEY NOT NULL
        LOOKAHEAD( InlineConstraint() )
          (
  	    wasPK = InlineConstraint()
  	    {
  		isPK |= wasPK;
  	    }
  	)*
        | LOOKAHEAD( InlineRefConstraint() ) (InlineRefConstraint())*
        | {}
      )
    | 
      (
        LOOKAHEAD( OutOfLineConstraint(tableInfo) ) OutOfLineConstraint(tableInfo)
      | LOOKAHEAD ( OutOfLineRefConstraint() ) OutOfLineRefConstraint()
      )
    | SupplementalLoggingProps()
  )
  {
      if (isPK) {
	  System.out.println("add pk " + columnName);
	  tableInfo.addPK(columnName.toLowerCase());
      }
  }
}

void Expr() :
{}
{
  (
    (
      LOOKAHEAD( SimpleExpression() ) SimpleExpression()
      | LOOKAHEAD ( ObjectAccessExpression() ) ObjectAccessExpression()
      | LOOKAHEAD ( TypeConstructorExpression() ) TypeConstructorExpression()
      | LOOKAHEAD ( "(" Expr() ")" )  "(" Expr() ")"
      | LOOKAHEAD ( ( "+" | "-" | "prior" ) Expr() ) ( "+" | "-" | "prior" ) Expr()
    )
//    | CompoundExpression()
    | CaseExpression()
    | CursorExpression()
//    | DatetimeExpression()
//     | FunctionExpression() // currently don't support function expr..
//    | IntervalExpression()
//     | ScalarSubqueryExpression() // currently don't support scalar subquery expr..
    | VariableExpression()
  )
  // left recursion
  // | Expr() ( "*" | "/" | "+" | "-" | "||" ) Expr()
  // resolving left recursion
  (
    LOOKAHEAD(2)
    (
      ( "*" | "/" | "+" | "-" | "||" ) Expr()
    |
       "at"
      (
        "local"
        | "time" "zone"
        (
          LOOKAHEAD (2)
              "'" [ "+" | "-" ] "hh" ":" "mm" "'"
          | "dbtimezone"
          | "sessiontimezone"
          | LOOKAHEAD (2) "'" TimeZoneName() "'"
          | Expr()
        )
      )
    |
      (
        "day" "to" "second"
        | "year" "to" "month"
      )
    )
  )*
}

void SimpleExpression() :
{}
{
  (
     // cannot distinguish identifiers
/*
    [
      (
        QueryName()
      | [ Schema() ] ( Table() | View() | MaterializedView() )
      ) "."
    ]
*/
    (
      LOOKAHEAD(2) Name() "."
    | LOOKAHEAD(3) Name() Name() "."
    | {}
    )
    (
      LOOKAHEAD ( Sequence() "." ( "currval" | "nextval" ) )
        Sequence() "." ( "currval" | "nextval" )
    | ( Column() | "rowid" )
    | "rownum"
    | Text()
    | Number()
    | "null"
    )
  )
}

/*
void CompoundExpression() :
{}
{
  "(" Expr() ")"
  | ( "+" | "-" | "prior" ) Expr()
  // HERE left recursion
  | Expr() ( "*" | "/" | "+" | "-" | "||" ) Expr()
}
*/

void CaseExpression() :
{}
{
  "case"
  ( SimpleCaseExpression() | SearchedCaseExpression() )
  [ ElseClause() ]
  "end"
}

void SimpleCaseExpression() :
{}
{
  Expr()
  (
    "when"
    ComparisonExpr()
    "then"
    ReturnExpr()
  )+
}

void ComparisonExpr() :
{}
{
    Expr() // XXX : is this right?
}

void ReturnExpr() :
{}
{
    Expr() // XXX : is this right?
}

void ElseExpr() :
{}
{
    Expr() // XXX : is this right?
}

/*
void DatetimeValueExpr() :
{}
{
    Expr() // XXX : is this right?
}
*/

/*
void IntervalValueExpr() :
{}
{
    Expr() // XXX : is this right?
}
*/

void ColumnExpression() :
{}
{
    Expr() // XXX : is this right?
}

void SearchedCaseExpression() :
{}
{
  (
    "when"
    Condition()
    "then"
    ReturnExpr()
  )+
}

void Condition() :
{}
{
  (
    LOOKAHEAD ( ComparisonCondition() ) ComparisonCondition()
//       | LogicalCondition()
    | LOOKAHEAD ( MembershipCondition() ) MembershipCondition()
    | LOOKAHEAD ( RangeCondition() ) RangeCondition()
    | LOOKAHEAD ( NullCondition() ) NullCondition()
    | EqualsPath()
    | ExistsCondition()
    | LikeCondition()
    | LOOKAHEAD ( UnderPath() ) UnderPath()
//   | CompoundCondition() // compound condition translated to below lines
    | LOOKAHEAD (3) "(" Condition() ")" 
    | IsOfTypeCondition()
    | "not" Condition()
  )
  // resolve left recursion
  //  | Condition() ( "and" | "or" ) Condition()
  ( LOOKAHEAD(2) ( "and" | "or" ) Condition() )*
}

void ComparisonCondition() :
{}
{
  LOOKAHEAD ( SimpleComparisonCondition() ) SimpleComparisonCondition()
  | GroupComparisonCondition()
}

void SimpleComparisonCondition() :
{}
{
  LOOKAHEAD ( Expr() ( "=" | "!=" | "^=" | "<>" | ">" | "<" | ">=" |
              "<=" ) Expr() )
    Expr() ( "=" | "!=" | "^=" | "<>" | ">" | "<" | ">=" | "<=" ) Expr()
  | "(" Expr() ( "," Expr() )* ")" ( "=" | "!=" | "^=" | "<>" ) "(" Subquery() ")"
}

void GroupComparisonCondition() :
{}
{
  LOOKAHEAD (
     Expr() ( "=" | "!=" | "^=" | "<>" | ">" | "<" | ">=" | "<=" )
       ( "any" | "some" | "all" ) "(" ( ExpressionList() | Subquery()
       ) ")"
    )
    Expr() ( "=" | "!=" | "^=" | "<>" | ">" | "<" | ">=" | "<=" )
      ( "any" | "some" | "all" ) "(" ( ExpressionList() | Subquery()
      ) ")"
  | "(" Expr() ( "," Expr() )* ")" ( "=" | "!=" | "^=" | "<>" )
    ( "any" | "some" | "all" ) "(" ( ExpressionList() ( "'" ExpressionList() ) | Subquery() ) ")"
}

void ExpressionList() :
{}
{
  LOOKAHEAD ( Expr() ( "," Expr() )* )
    Expr() ( "," Expr() )*
  | "(" Expr() ( "," Expr() )* ")"
}

void MembershipCondition() :
{}
{
  LOOKAHEAD (
    Expr() [ "not" ] "in" "(" ( ExpressionList() | Subquery() ) ")"
  )
  Expr() [ "not" ] "in" "(" ( ExpressionList() | Subquery() ) ")"
  | "(" Expr() ( "," Expr() )* ")" [ "not" ] "in" "(" ( ExpressionList() ( "'" ExpressionList() ) | Subquery() ) ")"
}

void RangeCondition() :
{}
{
  Expr() [ "not" ] "between" Expr() "and" Expr()
}

void NullCondition() :
{}
{
    Expr() "is" [ "not" ] "null" 
}

void EqualsPath() :
{}
{
    "equals_path" "(" Column() "," PathString() [ "," CorrelationInteger() ] ")"
}

void ExistsCondition() :
{}
{
    "exists" "(" Subquery() ")"
}

void LikeCondition() :
{}
{
    Char() [ "not" ] ( "like" | "likec" | "like2" | "like4" ) Char() [ "escape" Char() ]
}

void IsOfTypeCondition() :
{}
{
    Expr() "is" [ "not" ] "of" [ "type" ] "("
    [ [ "only" ] [ Schema() "." ] Type() ( "," [ "only" ] [ Schema() "." ] Type() )* ]
    ")"
}

void UnderPath() :
{}
{
    "under_path" "(" Column() [ "," Levels() ] "," PathString()
	[ "," CorrelationInteger() ] ")"
}

/*
void CompoundCondition() :
{}
{
  "(" Condition() ")"
  | "not" Condition()
  // left recursion
  | Condition() ( "and" | "or" ) Condition()
}
*/

void ElseClause() :
{}
{
  "else" ElseExpr()
}

void CursorExpression() :
{}
{
  "cursor" "(" Subquery() ")"
}

/*
void DatetimeExpression() :
{}
{
  // HERE left recursion
  DatetimeValueExpr() "at"
  (
    "local"
    | "time" "zone"
      (
        "'" [ "+" | "-" ] "hh" ":" "mm" "'"
        | "dbtimezone"
        | "sessiontimezone"
        | "'" TimeZoneName() "'"
        | Expr()
      )
  )
}
*/

// void FunctionExpression() :
// {}
// {
//     // how to check the validity?
// }

/*
void IntervalExpression() : 
{}
{
  IntervalValueExpr()
  (
    "day" "to" "second"
    | "year" "to" "month"
  )
}
*/

void ObjectAccessExpression() :
{}
{
  (
    LOOKAHEAD (
      TableAlias() "." Column() "."
    )
    TableAlias() "." Column() "."
    | LOOKAHEAD (
      ObjectTableAlias() "."
    )
    ObjectTableAlias() "."
    | "(" Expr() ")" "."
  )
  (
    LOOKAHEAD (
      Attribute() ( "." Attribute() )*
        [ "." Method() "(" [ Argument() ("," Argument())* ] ")" ]
    )
    Attribute() ( "." Attribute() )*
      [ "." Method() "(" [ Argument() ("," Argument())* ] ")" ]
    | Method() "(" [ Argument() ("," Argument())* ] ")"
  )
}

void TypeConstructorExpression() :
{}
{
  [ "new" ] [ Schema() "." ] TypeName() "(" [ Expr() ( "," Expr() )* ] ")"
}

void VariableExpression() :
{}
{
  ":" HostVariable() [ [ "indicator" ] ":" IndicatorVariable() ]
}

boolean InlineConstraint() :
{
    boolean isPK = false;
}
{
    [ "constraint" ConstraintName() ]
    (
      [ "not" ] "null"
    | "unique"
    | "primary" "key"
      {
	  isPK = true;
      }
    | ReferencesClause()
    | "check" "(" Condition() ")"
    )
    ( LOOKAHEAD( ConstraintState() ) ConstraintState() | {} )

    {
        return isPK;
    }
}

void OutOfLineConstraint(TableInfo tableInfo) :
{
    String name = null;
}
{
    [ "constraint" ConstraintName() ]
    ( "unique" "(" Column() ( "," Column() )* ")"
      | "primary" "key" "("
          name = Column()
          {
		tableInfo.addPK(name.toLowerCase());
          }
          ( ","
	      name = Column()
	      {
		tableInfo.addPK(name.toLowerCase());
	      }
          )* ")"
      | "foreign" "key" "(" Column() ( "," Column() )* ")" ReferencesClause()
      | "check" "(" Condition() ")"
    )
    ( LOOKAHEAD( ConstraintState() ) ConstraintState() | {} )
}

void InlineRefConstraint() :
{}
{
  (
     "scope" "is" [ Schema() "." ] ScopeTable()
    | "with" "rowid"
    | [ "constraint" ConstraintName()] ReferencesClause()
      ( LOOKAHEAD( ConstraintState() ) ConstraintState() | {} )
  )
}

void OutOfLineRefConstraint() :
{}
{
  (
     "scope" "for" "(" ( /* RefCol() | RefAttr() */ Name() ) ")" "is" [ Schema() "." ] ScopeTable()
    | "ref" "(" ( /* RefCol() | RefAttr() */ Name() ) ")" "with" "rowid"
    | [ "constraint" ConstraintName() ] "foreign" "key"
      "(" ( /* RefCol() | RefAttr() */ Name() ) ")" 
      ReferencesClause()
      ( LOOKAHEAD( ConstraintState() ) ConstraintState() | {} )
   )
}

void ReferencesClause() :
{}
{
    "references" [ Schema() "." ] Object()
	[ "(" Column() ")" ] [ "on" "delete" ( "cascade" | "set" "null" ) ]
}

void ConstraintState() :
{}
{
  (
    (
      LOOKAHEAD(2)
      ["not"] "deferrable"
      | "initially" ( "immediate" | "deferred" )
      | ( "enable" | "disable" )
      | ( "validate" | "novalidate" )
      | ( "rely" | "norely" )
      | UsingIndexClause()
      | ExceptionsClause()
    )
  )+
}

void UsingIndexClause() :
{}
{
    "using" "index"
    (
      [ Schema() "." ] Index()
      | CreateIndexStatement()
      | (
	  "pctfree" Integer()
          | "initrans" Integer()
	  | "maxtrans" Integer()
	  | "tablespace" Tablespace()
	  | StorageClause()
	  | "nosort"
	  | LoggingClause()
	  | ( "local" | GlobalPartitionedIndex() )
        )*
    )
}

void CreateIndexStatement() :
{}
{
    "create" [ "unique" | "bitmap" ] 
    "index" [ Schema() "." ]
    Index() "on"
    (
      ClusterIndexClause()
      | LOOKAHEAD ( TableIndexClause() ) TableIndexClause()
      | BitmapJoinIndexClause()
    )
}

void ClusterIndexClause() :
{}
{
  "cluster" [ Schema() "." ]
  Cluster() [ IndexAttributes() ]
}

void TableIndexClause() :
{}
{
  [ Schema() "." ]
  Table() [ TAlias() ]
  "("
  IndexExpr() [ "asc" | "desc" ]
  ( "," IndexExpr() [ "asc" | "desc" ] )*
  ")"
  (
    LOOKAHEAD ( TableIndexClauseOptionalPart() )
      (TableIndexClauseOptionalPart())*
    | LOOKAHEAD ( DomainIndexClause() )
      DomainIndexClause()
    | {}
  )
}

/* just a part of table index clause */
void TableIndexClauseOptionalPart() :
{}
{
  GlobalPartitionedIndex()
  | LocalPartitionedIndex()
  | IndexAttributes()
}

void BitmapJoinIndexClause() :
{}
{
  [ Schema() "." ]
  Table() "("
  [
    (
      [ Schema() "." ] Table() "."
      // cannot tell talias from table
      // | TAlias() "."
    )
  ]
  Column()
  [ "asc" | "desc" ]
  (
    ","
    [
      (
        [ Schema() "." ] Table() "."
        // cannot tell talias from table
        // | TAlias() "."
      )
    ]
    Column()
    [ "asc" | "desc" ]
  )*
  ")"
  "from"
  [ Schema() "." ]
  Table()
  [ TAlias() ]
  (
    ","
    [ Schema() "." ]
    Table()
    [ TAlias() ]
  )*
  "where" Condition() [ LocalPartitionedIndex() ] [ IndexAttributes() ]
}

/*
 * NOTE : this is marked as an optional part!!!
 * So referencing productions should make this as an optional!
 * current production set has no problem
 */
void IndexAttributes() :
{}
{
  PhysicalAttributesClause()
  | LoggingClause()
  | "online"
  | "compute" "statistics"
  | "tablespace" ( Tablespace() | "default" )
  | KeyCompression()
  | "nosort"
  | "reverse"
  | ParallelClause()
}

void IndexExpr() :
{}
{
  (
    Column()
    | ColumnExpression()
  )
}

void GlobalPartitionedIndex() :
{}
{
    "global" "partition" "by" "range" "(" ColumnList() ")"
	"(" IndexPartitioningClause() ")"
}

void LocalPartitionedIndex() :
{}
{
  "local"
  [
    OnRangePartitionedTable()
//    | OnListPartitionedTable() // the grammar looks same with on_range_partitioned_table
    | LOOKAHEAD ( OnHashPartitionedTable() ) OnHashPartitionedTable()
    | OnCompPartitionedTable()
  ]
}

void OnRangePartitionedTable() :
{}
{
  "("
  "partition"
  [ Partition()
   (
     LOOKAHEAD (SegmentAttributesClause())
       ( SegmentAttributesClause() )*
     | {}
   )
  ]
  ( "," [ Partition()
          (
            LOOKAHEAD (SegmentAttributesClause())
              ( SegmentAttributesClause() )*
            | {}
          )
        ] )*
  ")"
}

/*
void OnListPartitionedTable() :
{}
{

}
*/

void OnHashPartitionedTable() :
{}
{
  (
    "store" "in" "(" Tablespace() ( "," Tablespace() )* ")"
    | "(" "partition" [ Partition() [ "tablespace" Tablespace() ]]
      ( "," "partition" [ Partition() [ "tablespace" Tablespace() ]])*
      ")"
  )
}

void OnCompPartitionedTable() :
{}
{
  [ "store" "in" "(" Tablespace() ( "," Tablespace() )* ")" ]
  "(" "partition" [ Partition()
     (
       LOOKAHEAD (SegmentAttributesClause())
         ( SegmentAttributesClause() )*
       | {}
     )
  [ IndexSubpartitionClause() ]]
  ( "," "partition" [ Partition()
     (
       LOOKAHEAD (SegmentAttributesClause())
         ( SegmentAttributesClause() )*
       | {}
     )
    [ IndexSubpartitionClause() ]] )*
  ")"
}

void DomainIndexClause() :
{}
{
  "indextype" "is" Indextype() [ ParallelClause() ]
  [ "parameters" "(" "'" ODCIParameters() "'" ")" ]
}

void IndexSubpartitionClause() :
{}
{
  (
    "store" "in" "(" Tablespace() ( "," Tablespace() )* ")"
    | "(" "subpartition" [ Subpartition() [ "tablespace" Tablespace() ]]
      ( "," "subpartition" [ Subpartition() [ "tablespace" Tablespace() ]])*
      ")"
  )
}

void ColumnList() :
{}
{
  Column() ( "," Column() )*
}

void IndexPartitioningClause() :
{}
{
    "partition" Partition() "values" "less" "than" "(" Value() ( "," Value() )* ")"
	[ SegmentAttributesClause() ]
}

void SegmentAttributesClause() :
{}
{
  (
    PhysicalAttributesClause()
    | LoggingClause()
    | "tablespace" Tablespace()
  )+
}

/*
 * NOTE!!! this clause is marked as optional in sql reference.
 * So, referencing production should take this optional!!!
 * current production set has no problem
 */
void PhysicalAttributesClause() :
{}
{
  "pctfree" Integer()
  | "pctused" Integer()
  | "initrans" Integer()
  | "maxtrans" Integer()
  | StorageClause()
}

void LoggingClause() :
{}
{
  "logging"
  | "nologging"
}

void StorageClause() :
{}
{
  "storage" "("
  (
    "initial" Integer() [ "k" | "m" ]
    | "next" Integer() [ "k" | "m" ]
    | "minextents" Integer()
    | "maxextents"
      (
        LOOKAHEAD (Integer())
         Integer()
        | "unlimited"
        | {}
      )
    | "pctincrease" Integer()
    | "freelists" Integer()
    | "freelist" "groups" Integer()
    | "optimal"
      (
        LOOKAHEAD (Integer())
          Integer() [ "k" | "m" ]
        | "null"
        | {}
      )
    | "buffer_pool" ( "keep" | "recycle" | "default" )
  )*
  ")"
}

void ExceptionsClause() :
{}
{
  "exceptions" "into" [ Schema() "." ] Table()
}

void PhysicalProperties() :
{}
{
  (
    SegmentAttributesClause() [ DataSegmentCompression() ]
    | "organization"
      (
        "heap"
        (
          LOOKAHEAD (SegmentAttributesClause())
          SegmentAttributesClause()
          | {}
        )
        [ DataSegmentCompression() ]
        | "index" 
          (
            LOOKAHEAD (SegmentAttributesClause())
            SegmentAttributesClause()
            | {}
          )
          IndexOrgTableClause() 
        | "external"  ExternalTableClause()
      )
    | "cluster" Cluster() "(" Column() ( "," Column() )* ")"
  )
}

void TableProperties(TableInfo tableInfo) :
{}
{
  (
    LOOKAHEAD (ColumnProperties(tableInfo))
    ( ColumnProperties(tableInfo) )
    | {}
  )
  [ TablePartitioningClauses() ]
  [ RowMovementClause() ]
  [ "cache" | "nocache" ]
  [ "norowdependencies" | "rowdependencies" ]
  [ "monitoring" | "nomonitoring" ]
  [ ParallelClause() ]
  (
    LOOKAHEAD (EnableDisableClause(tableInfo))
    ( EnableDisableClause(tableInfo) )*
    | {}
  )
  [ "as" Subquery() ]
}

void ColumnProperties(TableInfo tableInfo) :
{}
{
  (
    ObjectTypeColProperties()
    | NestedTableColProperties(tableInfo)
    | ( VarrayColProperties() | LOBStorageClause() ) [
      LOBPartitionStorage() ]
    | XMLTypeColumnProperties()
  )*
}

void ObjectTypeColProperties() :
{}
{
  "column" Column() SubstitutableColumnClause()
}

void SubstitutableColumnClause() :
{}
{
  (
    [ "element" ] "is" "of" [ "type" ] "(" "only" Type() ")"
    | [ "not" ] "substitutable" "at" "all" "levels"
  )
}

void NestedTableColProperties(TableInfo tableInfo) :
{}
{
  "nested" "table" ( NestedItem() | "column_value" )
  [ SubstitutableColumnClause() ] 
  "store" "as" StorageTable()
  [ "(" "(" ObjectProperties(tableInfo) ")"
    (
      LOOKAHEAD(PhysicalProperties())
      PhysicalProperties()
      | {}
    )
    (
      LOOKAHEAD(ColumnProperties(tableInfo))
      ColumnProperties(tableInfo)
      | {}
    )
    ")" ]
  [ "return" "as" ( "locator" | "value" ) ]
}

void ObjectProperties(TableInfo tableInfo) :
{}
{
  (
    ( Column() /* cannot tell attribute from column */ /* | Attribute() */ ) [ "default" Expr() ]
      (
        LOOKAHEAD ( ( InlineConstraint() )* | InlineRefConstraint() )
        ( ( InlineConstraint() )* | InlineRefConstraint() )
        | {}
      )
    |
      (
        (
          LOOKAHEAD( OutOfLineConstraint(tableInfo) ) OutOfLineConstraint(tableInfo)
        | LOOKAHEAD ( OutOfLineRefConstraint() ) OutOfLineRefConstraint()
        )
        | SupplementalLoggingProps()
      )
  )
}

void TablePartitioningClauses() :
{}
{
  (
    LOOKAHEAD ( RangePartitioning() ) RangePartitioning()
    | LOOKAHEAD ( HashPartitioning() ) HashPartitioning()
    | LOOKAHEAD ( ListPartitioning() ) ListPartitioning()
    | CompositePartitioning()
  )
}

void RangePartitioning() :
{}
{
  "partition" "by" "range" "("
  Column() ( "," Column() )* ")"
  "(" "partition" [ Partition() ] RangeValuesClause() TablePartitionDescription()
  ( ","  "partition" [ Partition() ] RangeValuesClause() TablePartitionDescription() )*
   ")"
}

void RangeValuesClause() :
{}
{
    "values" "less" "than" "(" ( Value() | "maxvalue" ) ( "," ( Value() | "maxvalue" ) )* ")"
}

void Value() :
{}
{
  "value" "(" CorrelationVariable() ")"
}

void HashPartitioning() :
{}
{
  "partition" "by" "hash" "(" Column() ( "," Column() )* ")"
  (
    IndividualHashPartitions()
    | HashPartitionsByQuantity()
  )
}

void ListPartitioning() :
{}
{
  "partition" "by" "list" "(" Column() ")" "("
  "partition" [ Partition() ] ListValuesClause()
  TablePartitionDescription()
  (
    "," 
    "partition" [ Partition() ] ListValuesClause()
    TablePartitionDescription()
  )*
  ")"
}

void CompositePartitioning() :
{}
{
  "partition" "by" "range" "(" ColumnList() ")"
  (
    LOOKAHEAD ( SubpartitionByList() ) SubpartitionByList()
    | SubpartitionByHash()
  )
  "("
  "partition" [ Partition() ] RangeValuesClause()
  TablePartitionDescription()
  ( "," "partition" [ Partition() ] RangeValuesClause()
    TablePartitionDescription() )*
  ")"
}

void SubpartitionByHash() :
{}
{
  "subpartition" "by" "hash" "(" Column() ( "," Column() )* ")"
  [
    (
      "subpartitions" Quantity()
      [ "store" "in" "(" Tablespace() ( "," Tablespace() )* ")" ]
      | SubpartitionTemplate() 
    )
  ]
}

void IndividualHashPartitions() :
{}
{
  "(" "partition" [ Partition() PartitioningStorageClause() ]
  ( "," "partition" [ Partition() PartitioningStorageClause() ] ) *
  ")"
}

void HashPartitionsByQuantity() :
{}
{
  "partitions" HashPartitionQuantity()
  [ "store" "in" "(" Tablespace() ( "," Tablespace() )* ")" ]
  [ "overflow" "store" "in" "(" Tablespace() ( "," Tablespace() )* ")" ]
}

void SubpartitionByList() :
{}
{
  "subpartition" "by" "list" "(" Column() ")" [ SubpartitionTemplate() ]
}

void SubpartitionTemplate() :
{}
{
  "subpartition" "template"
  (
    "("
    "subpartition" Subpartition()
    [ ListValuesClause() ]
    (
      LOOKAHEAD (PartitioningStorageClause())
      PartitioningStorageClause()
      | {}
    )
    (
      ","  "subpartition" Subpartition()
      [ ListValuesClause() ]
      (
        LOOKAHEAD (PartitioningStorageClause())
        PartitioningStorageClause()
        | {}
      )
    )*
    ")"
   | HashSubpartitionQuantity()
  )
}

void ListValuesClause() :
{}
{
  "values" "("
  (
    ( Value() | "null" )
    ( "," ( Value() | "null" ))*
    | "default"
  )
  ")"
}

void PartitioningStorageClause() :
{}
{
  (
    "tablespace" Tablespace()
    | "overflow" [ "tablespace" Tablespace() ]
    | "lob" "(" LOBItem() ")" "store" "as"
      ( LOBSegname() [ "(" "tablespace" Tablespace() ")" ]
        | "(" "tablespace" Tablespace() ")" )
    | "varray" VarrayItem() "store" "as" "lob" LOBSegname()
  )*
}

void TablePartitionDescription() :
{}
{
  (
    LOOKAHEAD ( SegmentAttributesClause() )
    SegmentAttributesClause()
    | {}
  )
  [ DataSegmentCompression() ]
  [ KeyCompression() ]
  [ "overflow"
    (
      LOOKAHEAD ( SegmentAttributesClause() )
      SegmentAttributesClause()
      | {}
    )
  ]
  (
    LOOKAHEAD ( LOBStorageClause() | VarrayColProperties() )
    ( LOBStorageClause() | VarrayColProperties() )*
    | {}
  )
  [ PartitionLevelSubpartition() ]
}

void DataSegmentCompression() :
{}
{
  (
    "compress"
    | "nocompress"
  )
}

void KeyCompression() :
{}
{
  "compress"
  (
    LOOKAHEAD( Integer() )
    Integer()
    | {}
  )
  | "nocompress"
}

void ParallelClause() :
{}
{
  "noparallel"
  | "parallel"
    (
      LOOKAHEAD( Integer() )
      Integer()
      | {}
    )
}

void EnableDisableClause(TableInfo tableInfo) :
{}
{
  ( "enable" | "disable" ) [ ( "validate" | "novalidate" ) ]
  (
    "unique" "(" Column() ( "," Column() )* ")"
    | "primary" "key"
    | "constraint" Constraints(tableInfo) 
  )
  [ UsingIndexClause() ] 
  [ ExceptionsClause() ]
  [ "cascade" ]
  [ ( "keep" | "drop" ) "index" ]
}

void Constraints(TableInfo tableInfo) :
{}
{
  (
    InlineConstraint()
    | InlineRefConstraint()
    (
      LOOKAHEAD( OutOfLineConstraint(tableInfo) ) OutOfLineConstraint(tableInfo)
    | LOOKAHEAD ( OutOfLineRefConstraint() ) OutOfLineRefConstraint()
    )
  )
}

void RowMovementClause() :
{}
{
  ( "enable" | "disable" ) "row" "movement"
}

void VarrayColProperties() :
{}
{
  "varray" VarrayItem()
  (
    SubstitutableColumnClause()
    | "store" "as" "lob"
      (
        LOOKAHEAD ( LOBSegname() "(" LOBParameters() ")" )
          LOBSegname() "(" LOBParameters() ")"
        | LOBSegname()
        | "(" LOBParameters() ")"
      )
   )
}

void PartitionLevelSubpartition() :
{}
{
  (
    "subpartitions" HashSubpartitionQuantity()
      [ "store" "in" "(" Tablespace() ( "," Tablespace() )* ")" ]
    | "(" SubpartitionSpec() ( "," SubpartitionSpec() )* ")"
  )
}

void SubpartitionSpec() :
{}
{
  "subpartition" [ Subpartition() ] [ ListValuesClause() ]
  ( 
    LOOKAHEAD (PartitioningStorageClause())
    PartitioningStorageClause()
    | {}
  )
}

void LOBStorageClause() :
{}
{
  "lob"
  (
    LOOKAHEAD ( 
      "(" LOBItem() ( "," LOBItem() )* ")" "store" "as" "("
      LOBParameters() ")"
    )
    "(" LOBItem() ( "," LOBItem() )* ")" "store" "as" "("
    LOBParameters() ")"
    | "(" LOBItem() ")" "store" "as"
      (
        LOOKAHEAD ( LOBSegname() "(" LOBParameters() ")" )
          LOBSegname() "(" LOBParameters() ")" 
        | LOBSegname()
        | "(" LOBParameters() ")"
      )
  )
}

void LOBPartitionStorage() :
{}
{
  "partition" Partition() 
  (
    LOBStorageClause()
    | VarrayColProperties()
  )*
  [ "(" "subpartition" Subpartition()
    (
      LOBStorageClause()
      | VarrayColProperties()
    )*
    ")"
  ]
}

void XMLTypeColumnProperties() :
{}
{
  "xmltype" [ "column" ] Column()
  [ XMLTypeStorage() ] [ XMLSchemaSpec() ]
}

void XMLTypeStorage() :
{}
{
  "store" "as"
  (
    "object" "relational"
    | "clob" 
      (
        LOOKAHEAD (LOBSegname())
          LOBSegname() [ "(" LOBParameters() ")" ]
        | LOOKAHEAD (LOBParameters())
          LOBParameters()
        | {}
      )
   )
}

void XMLSchemaSpec() :
{}
{
  [ "xmlschema" XMLSchemaURL() ]
  "element"
  (
    LOOKAHEAD ( XMLSchemaURL() "#" Element() )
      XMLSchemaURL() "#" Element()
    | Element()
  )
}

void IndexOrgTableClause() :
{}
{
  (
    LOOKAHEAD
    (
      MappingTableClause()
      | "pcthreshold" Integer()
      | KeyCompression()
    )
    (
      MappingTableClause()
      | "pcthreshold" Integer()
      | KeyCompression()
    )*
    | {}
  )
  [
    IndexOrgOverflowClause()
  ]
}

void IndexOrgOverflowClause() :
{}
{
  [
    "including" ColumnName()
  ]
  "overflow"
  (
    LOOKAHEAD ( SegmentAttributesClause() )
      SegmentAttributesClause() | {}
  )
}

void ExternalTableClause() :
{}
{
  "(" [ "type" AccessDriverType() ]
  ExternalDataProperties() ")"
  [
    "reject" "limit" ( Integer() | "unlimited" )
  ]
}

void ExternalDataProperties() :
{}
{
  "default" "directory" Directory()
  [ "access" "parameters"
    (
       "(" OpaqueFormatSpec() ")"
       | "using" "clob" Subquery()
     )
  ]
  "location" "("
  [ Directory() ":" ] "'" LocationSpecifier() "'"
  ( "," [ Directory() ":" ] "'" LocationSpecifier() "'" )*
  ")"
}

void MappingTableClause() :
{}
{
  ( "mapping" "table" | "nomapping" )
}

void LOBParameters() :
{}
{
  (
    "tablespace" Tablespace()
    | ( "enable" | "disable" ) "storage" "in" "row"
    | StorageClause()
    | "chunk" Integer()
    | "pctversion" Integer()
    | "retention"
    | "freepools" Integer()
    | (
        "cache"
        | ( "nocache" | "cache" "reads" ) [ LoggingClause() ]
      )
  )*
}

void Subquery() :
{}
{
    [ SubqueryFactoringClause() ] "select" /* [ Hint() ] */ [ ( ( "distinct" | "unique" ) | "all" ) ]
	SelectList() "from" TableReference() ( "," TableReference() )*
        [ "where" Condition() ] [ HierarchicalQueryClause() ] [ GroupByClause() ] 
        [ "having" Condition() ]
        [ ( "union" [ "all" ] | "intersect" | "minus" ) "(" Subquery() ")" ]
        [ OrderByClause() ]
}

void SubqueryFactoringClause() :
{}
{
    "with" QueryName() "as" "(" Subquery() ")" ( "," QueryName() "as" "(" Subquery() ")" )*
}

void SelectList() :
{}
{
  (
    "*"
    | (
      ( LOOKAHEAD(3) Name() "." | Name() Name() "." )
       // cannot tell id's
/*
        (
	  QueryName()
          | [ Schema() "." ]
	  ( Table()
            | View()
            | MaterializedView()
	  ) 
        )
*/
        ( LOOKAHEAD(2) Name() | [ Schema() "." ] Name() )
        ".*"
        | Expr() [ [ "as" ] CAlias() ]
      )
     ( "," (
             // cannot tell id's
/*
             (
               QueryName()
               | [ Schema() "." ]
                 ( Table()
                 | View()
                 | MaterializedView()
                 ) 
               )
*/
             ( LOOKAHEAD(2) Name() | [ Schema() "." ] Name() )
             ".*"
             | Expr() [ [ "as" ] CAlias() ]
            ) )*
  )
}

void HierarchicalQueryClause() :
{}
{
  [ "start" "with" Condition() ] "connect" "by" Condition()
}

void GroupByClause() :
{}
{
  "group" "by"
  (
    Expr()
    | RollupCubeClause()
    | GroupingSetsClause()
  )
  ( ","
    (
      Expr()
      | RollupCubeClause()
      | GroupingSetsClause()
    )
  )*
  [ "having" Condition() ]
}

void RollupCubeClause() :
{}
{
  ( "rollup" | "cube" ) "(" GroupingExpressionList() ")"
}

void GroupingSetsClause() :
{}
{
  "grouping" "sets" "("
  ( RollupCubeClause() | GroupingExpressionList() )
  ")"
}

void GroupingExpressionList() :
{}
{
  ExpressionList() ( "," ExpressionList() )*
}

void OrderByClause() :
{}
{
  "order" [ "siblings" ] "by"
  ( Expr() | Position() | CAlias() )
  [ ( "asc" | "desc" ) ]
  [ "nulls" ( "first" | "last" ) ]
  (
    "," 
    ( Expr() | Position() | CAlias() )
    [ ( "asc" | "desc" ) ]
    [ "nulls" ( "first" | "last" ) ]
  )*
}

FieldType Datatypes() :
{
  FieldType type = null;
}
{
  (
    type = OracleBuiltInDatatypes()
  | type = ANSISupportedDatatypes()
  // cannot tell below ids
  | type = UserDefinedTypes()
//  | OracleSuppliedTypes()
  )
  {
    System.out.println("data type : " + type);
    return type;
  }
}

FieldType OracleBuiltInDatatypes() :
{
  FieldType type = null;
}
{
  (
    type = CharacterDatatypes()
  | type = NumberDatatypes()
  | type = LongAndRawDatatypes()
  | type = DatetimeDatatypes()
  | type = LargeObjectDatatypes()
  | type = RowidDatatypes()
  )
  {
    return type;
  }
}

FieldType CharacterDatatypes() :
{
  String type = null;
  String size = null;
}
{
  (
    "char" [ "(" size = Size() [ "byte" | "char" ] ")" ] { type = "char"; }
  | "varchar2" "(" size = Size()  [ "byte" | "char" ] ")"
    { type = "varchar2"; }
  | "nchar" [ "(" size = Size() ")" { type = "nchar"; } ]
  | "nvarchar2" "(" size = Size() ")" { type = "nvarchar2"; }
  )
  {
    return new FieldType(type, size);
  }
}

FieldType NumberDatatypes() :
{
    String s1 = null;
    String s2 = null;
}
{
  "number" [ "(" s1 = Precision() [ "," s2 = Scale() ] ")" ]
  {
   String size = s1;
   if (s2 != null) {
     size += "," + s2;
   }
    return new FieldType("number", size);
  }
}

FieldType LongAndRawDatatypes() :
{
  String type = null;
  String size = null;
}
{
  (
    LOOKAHEAD(2) "long" "raw" { type = "long raw"; }
  | "long" { type = "long"; }
  | "raw" "(" size = Size() ")" { type = "raw"; }
  )
  {
    return new FieldType(type, size);
  }
}

FieldType DatetimeDatatypes() :
{
  String type = null;
  String p1 = null;
  String p2 = null;
}
{
  (
    "date" { type = "date"; }
  | "timestamp" { type = "timestamp"; }
    [ "(" p1 = FractionalSecondsPrecision() ")" ]
    [ "with" [ "local" ] "time" "zone" ]
  | LOOKAHEAD(2) "interval" "year" [ "(" p1 = YearPrecision() ")" ] "to" "month"
    { type = "interval year to month"; }
  | "interval" "day" [ "(" p1 = DayPrecision() ")" ] "to" "second" 
    [ "(" p2 = FractionalSecondsPrecision() ")" ]
    { type = "interval day to second"; }
  )
  {
    String size = p1;

    if (p2 != null) {
      size += "," + p2;
    }
    return new FieldType(type, size);
  }
}

FieldType LargeObjectDatatypes() :
{
  Token token = null;
}
{
  (
    "blob"
  | "clob"
  | "nclob"
  | "bfile"
  )
  {
    token = getToken(0);
    return new FieldType(token.image);
  }
}

FieldType RowidDatatypes() :
{
  String type = null;
  String size = null;
}
{
  (
    "rowid" { type = "rowid"; }
  | "urowid" [ "(" size = Size() ")" ] { type = "urowid"; }
  )
  {
    return new FieldType(type, size);
  }
}

FieldType ANSISupportedDatatypes() :
{
  String type = null;
  String s1 = null;
  String s2 = null;
}
{
  (
    "character" [ "varying" ] "(" s1 = Size() ")" { type = "character"; }
  | ( "char" { type = "char"; } | "nchar" { type = "nchar"; } )
    "varying" "(" s1 = Size() ")"
  | "varchar" "(" s1 = Size() ")" { type = "varchar"; }
  | "national"
    ( "character" { type = "national character"; }
    | "char" { type = "national char"; }
    ) [ "varying" ] "(" s1 = Size() ")"
  | ( "numeric" { type = "numeric"; }
    | "decimal" { type = "decimal"; }
    | "dec" { type = "dec"; } )
      [ "(" s1 = Precision() [ "," s2 = Scale() ] ")" ]
  | ( "integer" { type = "integer"; }
    | "int" { type = "int"; }
    | "smallint" { type = "smallint"; } )
  | "float" [ "(" s1 = Size() ")" ] { type = "float"; }
  | "double" "precision" { type = "double precision"; }
  | "real" { type = "real"; }
  )
  {
    String size = s1;

    if (s2 != null) {
	size += "," + s2;
    }
    return new FieldType(type, size);
  }
}

FieldType OracleSuppliedTypes() :
{
  String type = null;
}
{
  // cannot tell from each other, so...
  type = Type()
/*
  (
    AnyTypes()
  | XMLTypes()
  | SpatialType()
  | MediaTypes()
  )
*/
  {
    return new FieldType(type);
  }
}

/*
String AnyTypes() :
{
  String type = null;
}
{
  type = Type()

  // cannot tell from each other, so...
  (
    SYS_AnyData()
  | SYS_AnyType()
  | SYS_AnyDataSet()
  )

  {
    return type;
  }
}

String XMLTypes() :
{
  String type = null;
}
{
  type = Type()

  // cannot tell from each other, so...
  (
    XMLType()
  | URIType()
  )

  {
    return type;
  }
}

String SpatialType() :
{
  String type = null;
}
{
  type = MDSYS_SDO_Geometry()
  {
    return type;
  }
}

String MediaTypes() :
{
  String type = null;
}
{
  type = Type()
  // cannot tell from each other, so...

  (
    ORDSYS_ORDAudio()
  | ORDSYS_ORDImage()
  | ORDSYS_ORDVideo()
  | ORDSYS_ORDDoc()
  )

  {
    return type;
  }
}
*/

FieldType UserDefinedTypes() :
{
  String type = null;
}
{
  type = Type()
  {
    return new FieldType(type.toLowerCase());
  }
}

String Size() :
{
    String value = null;
}
{
  /* up to 4000 */
  value = Digits()
  {
      return value;
  }
}

String Precision() :
{
    String value = null;
}
{
  /* 1 ~ 38 */
  value = Digits()
  {
      return value;
  }
}

String Scale() :
{
    String value = null;
}
{
  /* -84 ~ 127 */
  value = Integer()
  {
      return value;
  }
}

String FractionalSecondsPrecision() :
{
    String value = null;
}
{
  /* 0 ~ 9 */
  value = Digit()
  {
      return value;
  }
}

String YearPrecision() :
{
    String value = null;
}
{
  /* 0 ~ 9 */
  value = Digit()
  {
    return value;
  }
}

String DayPrecision() :
{
    String value = null;
}
{
  /* 0 ~ 9 */
  value = Digit()
  {
    return value;
  }
}

/*
void SYS_AnyData() :
{
  String s;
}
{
  // XXX : is this right?
  s = Name()
}

void SYS_AnyType() :
{
  String s;
}
{
  // XXX : is this right?
  s = Name()
}

void SYS_AnyDataSet() :
{
  String s;
}
{
  // XXX : is this right?
  s = Name()
}
*/

/*
void XMLType() :
{
  String s;
}
{
  // XXX : is this right?
  s = Name()
}

void URIType() :
{
  String s;
}
{
  // XXX : is this right?
  s = Name()
}

String MDSYS_SDO_Geometry() :
{
  String s;
}
{
  // XXX : is this right?
  s = Name()
  {
    return s;
  }
}
*/

/*
void ORDSYS_ORDAudio() :
{
  String s;
}
{
  // XXX : is this right?
  s = Name()
}

void ORDSYS_ORDImage() :
{
  String s;
}
{
  // XXX : is this right?
  s = Name()
}

void ORDSYS_ORDVideo() :
{
  String s;
}
{
  // XXX : is this right?
  s = Name()
}

void ORDSYS_ORDDoc() :
{
  String s;
}
{
  // XXX : is this right?
  s = Name()
}
*/

void LOBSegname() :
{
    String s;
}
{
    s = Name()
}

void LOBItem() :
{
    String s;
}
{
    s = Name()
}

void Schema() :
{
    String s;
}
{
    s = Name()
}

String Table() :
{
    String s;
}
{
    s = Name()
    {
      System.out.println("table name : " + s);
      return s;
    }
}

void View() :
{
    String s;
}
{
    s = Name()
}

void MaterializedView() :
{
    String s;
}
{
    s = Name()
}

void Sequence() :
{
    String s;
}
{
    s = Name()
}

void Text() :
{}
{
    [ "n" ] "'" ( C() )* "'"
}

void Quantity() :
{}
{
  Number()
}

void HashPartitionQuantity() :
{}
{
  Number()
}

void HashSubpartitionQuantity() :
{}
{
  Number()
}

void Number() :
{}
{
  [ "+" | "-" ]
  (
    Digit() ( Digit() )* [ "." ( LOOKAHEAD ( Digit() ) ( Digit() )* | {} ) ]
    | "." Digit() ( Digit() )*
  )
  [ "e" [ ( "+" | "-" ) ] Digit() ( Digit() )* ]
}

String Digits() :
{
    String s = null;
    StringBuffer buffer = new StringBuffer();
}
{
  s = Digit() { buffer.append(s); }
  ( s = Digit() { buffer.append(s); } )*
  {
    return buffer.toString();
  }
}

String Column() :
{
    String s;
}
{
    s = Name()
    {
      System.out.println("column name - " + s);
      return s;
    }
}

String Type() :
{
  String s;
}
{
  s = Name()
  {
    return s;
  }
}

void QueryName() :
{
    String s;
}
{
    s = Name()
}

void Directory() :
{
    String s;
}
{
    // FIXME : is this right? mmm it should denote some path
    s = Name()
}

void LocationSpecifier() :
{
    String s;
}
{
    // FIXME : is this right? mmm it should denote some path
    s = Name()
}

void XMLSchemaURL() :
{
    String s;
}
{
    // FIXME : is this right? mmm it should denote some url
    s = Name()
}

void OpaqueFormatSpec() :
{
    String s;
}
{
    // XXX : is this right? mmm
    s = Name()
}

void TimeZoneName() :
{
    String s;
}
{
    s = Name()
}

void TableAlias() :
{
    String s;
}
{
    s = Name()
}

void ObjectTableAlias() :
{
    String s;
}
{
    s = Name()
}

void Attribute() :
{
    String s;
}
{
    s = Name()
}

void Method() :
{
    String s;
}
{
    s = Name()
}

void Argument() :
{
    String s;
}
{
    s = Name()
}

void TypeName() :
{
    String s;
}
{
    s = Name()
}

void HostVariable() :
{
    String s;
}
{
    s = Name()
}

void IndicatorVariable() :
{
    String s;
}
{
    s = Name()
}

void ConstraintName() :
{
    String s;
}
{
    s = Name()
}

void ScopeTable() :
{
    String s;
}
{
    s = Name()
}

void RefCol() :
{
    String s;
}
{
    s = Name()
}

void RefAttr() :
{
    String s;
}
{
    s = Name()
}

void Object() :
{
    String s;
}
{
    s = Name()
}

void Index() :
{
    String s;
}
{
    s = Name()
}

void Tablespace() :
{
    String s;
}
{
    s = Name()
}

void Partition() :
{
    String s;
}
{
    s = Name()
}

void Subpartition() :
{
    String s;
}
{
    s = Name()
}

void Cluster() :
{
    String s;
}
{
    s = Name()
}

void StorageTable() :
{
    String s;
}
{
    s = Name()
}

void LogGroup() :
{
    String s;
}
{
    s = Name()
}

void CorrelationVariable() :
{
    String s;
}
{
    s = Name()
}

void TableReference() :
{
    String s;
}
{
    s = Name()
}

void ColumnName() :
{
    String s;
}
{
    s = Name()
}

void NestedItem() :
{
    String s;
}
{
    s = Name()
}

void TAlias() :
{
    String s;
}
{
    s = Name()
}

void Indextype() :
{
    String s;
}
{
    s = Name()
}

void AccessDriverType() :
{
    String s;
}
{
    s = Name()
}

void VarrayItem() :
{
    String s;
}
{
   // XXX : is this right?
    s = Name()
}

void Element() :
{
    String s;
}
{
   // XXX : is this right? this should denote an XML element
    s = Name()
}

void ODCIParameters() :
{}
{
  // FIXME : does not support now
  <IDENTIFIER>
}

void CAlias() :
{}
{
    < LETTER >
}

void C() :
{}
{
    < LETTER >
}

void PathString() :
{}
{
    <CHAR_LITERAL>
}

void Position() :
{}
{
  Integer()
}

/*
 * generic id
 */
String Name() :
{
  Token t;
}
{
  ( <IDENTIFIER> /* | UnreservedKeyword() */ | <TYPE> | <YEAR> )
  {
    t = getToken(0);
    // System.out.println("name - " + t.image);
    return t.image;
  }
}

void SupplementalLoggingProps() :
{}
{
  "supplemental" "log" "group" LogGroup() "(" Column() ( "," Column() )* ")" [ "always" ]
}

// void ScalarSubqueryExpression() :
// {}
// {
//   <IDENTIFIER>
// }

void Char() :
{}
{
  <CHAR_LITERAL>
}

void Levels() :
{}
{
    Integer()
}

void CorrelationInteger() :
{}
{
    Integer()
}

String Integer() :
{
    Token t = null;
    StringBuffer buffer = new StringBuffer();
}
{
  [ "+" { buffer.append('+'); } | "-" { buffer.append('-'); } ]
  ( t = <DIGIT>  { buffer.append(t.image); } )*
  {
    return buffer.toString();
  }
}

String Digit() :
{
    Token t = null;
}
{
  t = <DIGIT>
  {
      return t.image;
  }
}

void UnreservedKeyword() :
{}
{
  < ALWAYS >
| < ANALYZE >
| < ASSOCIATE >
| < AT >
| < BFILE >
| < BITMAP >
| < BLOB >
| < BUFFER_POOL >
| < BYTE >
| < CACHE >
| < CALL >
| < CASCADE >
| < CASE >
| < CHARACTER >
| < CHUNK >
| < CLOB >
| < COLUMN_VALUE >
| < COMMIT >
| < COMPUTE >
| < CONSTRAINT >
| < CUBE >
| < CURRVAL >
| < CURSOR >
| < DAY >
| < DBTIMEZONE >
| < DEC >
| < DEFERRABLE >
| < DEFERRED >
| < DIRECTORY >
| < DISABLE >
| < DISASSOCIATE >
| < DOUBLE >
| < ELEMENT >
| < ENABLE >
| < END >
| < EQUALS_PATH >
| < ESCAPE >
| < EXCEPTIONS >
| < EXPLAIN >
| < EXTERNAL >
| < FIRST >
| < FOREIGN >
| < FREELIST >
| < FREELISTS >
| < FREEPOOLS >
| < GLOBAL >
| < GROUPING >
| < GROUPS >
| < HASH >
| < HEAP >
| < HH >
| < INCLUDING >
| < INDEXTYPE >
| < INDICATOR >
| < INITIALLY >
| < INITRANS >
| < INT >
| < INTERVAL >
| < KEEP >
| < KEY >
| < LAST >
| < LESS_STRING >
| < LEVELS >
| < LIKE2 >
| < LIKE4 >
| < LIKEC >
| < LIMIT >
| < LIST >
| < LOB >
| < LOCAL >
| < LOCATION >
| < LOCATOR >
| < LOG >
| < LOGGING >
| < MAPPING >
| < MAXTRANS >
| < MAXVALUE >
| < MERGE >
| < MINEXTENTS >
| < MM >
| < MONITORING >
| < MONTH >
| < MOVEMENT >
| < NATIONAL >
| < NCHAR >
| < NCLOB >
| < NESTED >
| < NEW >
| < NEXT >
| < NEXTVAL >
| < NOCACHE >
| < NOLOGGING >
| < NOMAPPING >
| < NOMONITORING >
| < NOPARALLEL >
| < NORELY >
| < NOROWDEPENDENCIES >
| < NOSORT >
| < NOVALIDATE >
| < NULLS >
| < NUMERIC >
| < NVARCHAR2 >
| < OBJECT >
| < ONLY >
| < OPTIMAL >
| < ORGANIZATION >
| < OVERFLOW >
| < PARALLEL >
| < PARAMETERS >
| < PARTITION >
| < PARTITIONS >
| < PCTHRESHOLD >
| < PCTINCREASE >
| < PCTUSED >
| < PCTVERSION >
| < PRECISION >
| < PRESERVE >
| < PRIMARY >
| < QUOTE >
| < RANGE >
| < READS >
| < REAL >
| < RECYCLE >
| < REF >
| < REFERENCES >
| < REJECT >
| < RELATIONAL >
| < RELY >
| < RETENTION >
| < RETURN >
| < REVERSE >
| < ROLLBACK >
| < ROLLUP >
| < ROWDEPENDENCIES >
| < SAVEPOINT >
| < SCOPE >
| < SECOND >
| < SESSIONTIMEZONE >
| < SETS >
| < SHARP >
| < SIBLINGS >
| < SOME >
| < SORT >
| < STATISTICS >
| < STORAGE >
| < STORE >
| < SUBPARTITION >
| < SUBPARTITIONS >
| < SUBSTITUTABLE >
| < SUPPLEMENTAL >
| < TABLESPACE >
| < TEMPLATE >
| < TEMPORARY >
| < THAN >
| < TIME >
| < TIMESTAMP >
| < TRUNCATE >
| < TYPE >
| < UNDER_PATH >
| < UNLIMITED >
| < UROWID >
| < USING >
| < VALUE >
| < VARRAY >
| < VARYING >
| < WHEN >
| < XMLSCHEMA >
| < XMLTYPE >
| < YEAR >
| < ZONE >
}
